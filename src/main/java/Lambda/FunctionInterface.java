package Lambda;

/*
    函数式接口：只有一个抽象方法的接口称之为函数接口
    常见的函数式接口
    Consumer 消费接口 accept  没有输出
    Function 计算转换接口 apply 有输出
    Predicate判断接口  test 有Boolean返回值
    Supplier 生产型接口

    常用的默认方法：
    以Predicate为例
    and:
    or:

    方法引用：
    在使用lambda时，如果方法体中只用一个方法的调用（包括构造方法），可以用方法引用进一步简化代码
    基本格式： 类名或者对象名::方法名

    引用类的静态方法：
    类名::方法名
        1.重写方法时，方法体中只有一行代码 并且代码是调用了某个类的静态方法
        2.并且重写的抽象方法中所有的参数都按照顺序传入了这个静态方法中
        这个时候就可以引用类的静态方法

    引用对象的实例方法：
    对象名::方法名
        1.重写方法时，方法体中只有一行代码 并且代码是调用了某个对象的成员方法
        2.并且重写的抽象方法中所有的参数都按照顺序传入了这个成员方法中
        这个时候就可以引用对象的实例方法

    引用类的实例方法：
    类名::方法名
        1. 重写方法时，方法体中只有一行代码 并且代码是调用了第一个参数的成员方法
        2.并且重写的抽象方法中剩余的所有参数都按照顺序传入了这个成员方法中
        这个时候就可以引用类的实例方法

    构造方法引用：
    如果方法体中的一行代码是构造器的话就可以使用构造器引用
    格式：类名::new
    使用条件：
        1. 重写方法时，方法体中只有一行代码 并且代码是调用了某个类的构造方法
        2.并且重写的抽象方法中所有的参数都按照顺序传入了这个构造方法中
        这个时候就可以引用构造器

     高级用法：
     基本数据类型优化：
     频繁的装箱和拆箱  以int为例 int转换成Integer称之为装箱；Integer转换成int称之为拆箱
     为了对此进行优化：提供了很多专门针对基本数据类型的方法 如mapToInt mapToLong mapToDouble

    并行流：
    当流中有大量元素，可以使用并行流去提高操作的效率 实际上就是把任务分配给多个线程去完成
    使用stream的话  只需要修改一个方法的调用就可以使用并行流帮助我们实现，从而提高效率
 */
public class FunctionInterface {
}
